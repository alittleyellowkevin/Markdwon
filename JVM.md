# JVM

### JVM概念

Java二进制字节码文件的运行环境，有着一次编写，到处运行的好处。并且能够实现自动内存管理，以及垃圾回收机制。

### JVM的结构

![截屏2024-08-05 19.17.30](/Users/huangkaiwen/Library/Application Support/typora-user-images/截屏2024-08-05 19.17.30.png)

类加载器：加载字节码文件到内存中

运行时数据区：管理JVM使用的内存

执行引擎：解释执行，自动回收

本地接口：调用虚拟机中C++方法

#### 类加载器

**启动类加载器**： 由C++编写实现，用于加载Java核心库 JAVA_HOME/jre/lib

**扩展类加载器**：用于加载扩展库JAVA_HOME/jre/lib/ext

**应用类加载器**：加载开发者自己编写的Java类

**自定义加载器：**自定义加载器

**双亲委派机制**：当一个类加载器接收到类的任务时，会向上查找是否加载过该类，再向下进行加载，通过这样的机制能够避免重复加载，保证类库不被修改，通过继承ClassLoader类，并重写"loadClass"方法们可以自定义类加载逻辑

**类的加载过程**：

​	加载：通过类名加载类数据到方法区，同时在堆中创建一个类实例并指向类数据用于创建的类对象

​	验证：验证类是否符合JVM规范

​	准备：为静态变量赋初始值，为final修饰的静态变量赋值

​	解析：将类中符号引用，转为直接引用

​	初始化：初始化静态变量，以及静态代码块

​	使用：JVM从入口方法开始执行代码

​	卸载：销毁类对象

#### 运行时数据区

**程序计数器**：线程私有的，内部保存字节码的行号，用于记录正在执行的字节码指令的地址

**堆**：线程共享区域，主要用来保存对象实例，数组等，当推中内存不够抛出OOM异常，堆中包含两大部分，一是**年轻代**，被分为三个部分，**Eden**区和两个大小严格相同的**Survivor区**，在多次垃圾回收后仍存在Survivor区的将进入**老年代**，

Java8前**方法区**保存类信息，静态变量，常量，编译后的代码，位于堆中

java8后**元空间**保存类信息，静态变量，常量，编译后的代码，位于本地内存 

**虚拟机栈**：每个线程运行时所需要的内存，成为虚拟机栈，线程每调用一个方法使用一个栈帧来保存，其中包括局部变量表，操作数栈，返回地址等，生命周期与线程相同。

**方法区**：Java8前方法区包括类信息，运行时常量池以及编译后的代码，位于堆中，java8后改名为**元空间**位于本地内存，常量池中包括类名，方法名，参数信息，字面量，属于某个类，当类被加载常量池信息就会被放在运行常量池，并将里面的符号地址变为真实地址

#### 执行引擎

**垃圾回收**：如果一个对象或多个对象没有任何引用指向它，那么这个对象现在就是垃圾，则有可能被回收。

**对象引用：**

  1、引用计数法：一个对象被引用了一次，则在对象的计数器上递增一次引用次数，如果这个对象引用次数为0，则可回收，当出现循环引用时，引用计数法将会失效。

  2、可达性分析法：扫描堆中的对象，看是否能沿着GC Root对象为起点的引用链找到该对象，找不到则可以回收， GC root主要包括虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象

**垃圾回收算法**：

1. 标记清除算法：根据可达性分析算法对垃圾进行标记，随后清除
2. 标记整理算法：解决了标记清除算法的碎片化问题，但是移动内存位置的步骤，其效率也有一定影响
3. 复制算法：在垃圾对象多的情况下，效率高，但是在同一时刻，只能使用一半

**分代回收算法**：新创建的对象先分配到eden区，当eden去内存不足，标记eden区和from区的存活对象将其复制到to区，如果再次内存不足则复制到from区，经过多次复制存活下来的对象晋升到老年代

<img src="/Users/huangkaiwen/Library/Application Support/typora-user-images/截屏2024-08-06 12.07.54.png" alt="截屏2024-08-06 12.07.54" style="zoom:50%;" />

1. MinorGC：发生在新生代的垃圾回收，暂停时间短
2. MixedGC：新生代+老年代部分区域的垃圾回收，G1收集器特有
3. FullGC：新生代+老年代完整垃圾回收

**垃圾回收器**：

1. **串行垃圾回收器**：垃圾回收时，只有一个线程在工作，并且Java应用中的所有线程要停下来等待回收完成

2. **并行垃圾回收器**：多个线程进行垃圾回收，所有线程都需要暂停等待垃圾回收完成

3. **CMC（并发）垃圾回收器**：是一款并发的针对老年代垃圾回收的，其特点是在垃圾回收时，应用仍能运行

4. **G1垃圾回收器**：

   **Young Collection**：首先挑出一些空闲区域作为eden区存储新对象，当eden需要回收时，挑出空闲区域作为幸存区，利用复制算法，如再有不足则将幸存区和eden区中老对象晋升到老年代，其余找一个新的幸存区复制

   **Concurrent Mark**: 当老年代内存超过45%，触发并发标记，并发标记结束后进入混合收集阶段，此时不会对所有老年代区域进行回收，而是根据暂停时间优先回收价值高的区域

   **Mixed Collection**：将eden和幸存者区复制到新的幸存者区，幸存者区和老年代复制到新的老年代

### JVM的调优

Javap -v xx.class 打印字节码信息

### JVM报错

栈空间不足：StackOverFlowError

堆空间不足：OutOfMemoryError

方法区内存不足：OutOfMemoryError：Metaspace

